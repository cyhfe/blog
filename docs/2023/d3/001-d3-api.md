# 理解 D3 transition

## selection

d3 的选择器可以链式调用

`append` 会改变返回值, 返回新添加的 DOM 节点

如果不想改变返回值,可以调用`call`接受当前`selection`作为参数

这个模式在`join`中的`exit`, `enter`, `update`中很实用.

```js
// return g2
const res = d3
  .select(innerChartRef.current)
  .append("g")
  .attr("class", "g1")
  .append("g")
  .attr("class", "g2")
  .call((g2) => g2.append("g").attr("class", "g3"));
```

[https://codesandbox.io/s/agitated-pascal-znf91o?file=/src/index.js](https://codesandbox.io/s/agitated-pascal-znf91o?file=/src/index.js)

## 过渡动画

```js
import * as d3 from "d3";

const svg = d3.select("#root");

function randomNumbers() {
  const output = new Set();
  while (output.size < 10) {
    output.add(d3.randomInt(0, 20)());
  }
  return Array.from(output);
}

async function update(data) {
  const t = svg.transition().duration(750);
  const texts = svg
    .selectAll("text")
    .data(data, (d) => d)
    .join(
      (enter) =>
        enter
          .append("text")
          .attr("fill", "blue")
          .attr("x", (d, i) => i * 30)
          .attr("y", -30)
          .text((d) => d)
          .call((enter) => enter.transition(t).attr("y", 30)),
      (update) =>
        update
          .attr("fill", "green")
          .call((update) => update.transition(t).attr("x", (d, i) => i * 30)),
      (exit) =>
        exit
          .attr("fill", "red")
          .call((exit) => exit.transition(t).attr("y", 1000).remove())
    )
    .call(async (texts) => {
      await texts.transition(t).end();

      texts
        .transition()
        .duration(100)
        .attr("x", (d, i) => i * 30)
        .attr("y", 30)
        .attr("fill", "black");
    });
}

let data;

function dataChange() {
  data = randomNumbers();
  update(data);
}

// const btn = document.getElementById("btn");
// btn.onclick = () => {
//   dataChange();
// };

setInterval(() => {
  dataChange();
}, 1000);
```
