# 消息队列（event loop）

## V8 执行过程

V8 执行 JavaScript 代码，需要经过编译和执行两个阶段，其中编译过程是指 V8 将 JavaScript 代码转换为字节码或者二进制机器代码的阶段，而执行阶段则是指解释器解释执行字节码，或者是 CPU 直接执行二进制机器代码的阶段。

![https://static001.geekbang.org/resource/image/fe/db/fe3d39715d28a833883df6702930a0db.jpg](https://static001.geekbang.org/resource/image/fe/db/fe3d39715d28a833883df6702930a0db.jpg)

## 惰性解析

惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码

## 如何创建闭包

JavaScript 的 3 个特性

1. 允许在函数内部定义新的函数
2. 可以在内部函数中访问父函数中定义的变量
3. 函数可以作为返回值

基于以上 3 个特性可以创建闭包

```js
function foo() {
  var d = 20
  return function inner(a, b) {
    const c = a + b + d
    return c
  }
}
const f = foo()
```

## 闭包给惰性解析带来的问题

我们可以分析下上面这段代码的执行过程：

- 当调用 foo 函数时，foo 函数会将它的内部函数 inner 返回给全局变量 f；

- 然后 foo 函数执行结束，执行上下文被 V8 销毁；

- 虽然 foo 函数的执行上下文被销毁了，但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d。

按照通用的做法，d 已经被 v8 销毁了，但是由于存活的函数 inner 依然引用了 foo 函数中的变量 d，这样就会带来两个问题：

- 当 foo 执行结束时，变量 d 该不该被销毁？如果不应该被销毁，那么应该采用什么策略？

- 如果采用了惰性解析，那么当执行到 foo 函数时，V8 只会解析 foo 函数，并不会解析内部的 inner 函数，那么这时候 V8 就不知道 inner 函数中是否引用了 foo 函数的变量 d。

## 预解析器如何解决闭包所带来的问题？

V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个。

- 判断当前函数是不是存在一些语法上的错误
- 除了检查语法错误之外，预解析器另外的一个重要的功能就是检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。

## 一句话总结

闭包引用的变量是保存在堆中的。
